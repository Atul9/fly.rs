union Any {
  TimerStart,
  TimerReady,
  TimerClear,
  HttpRequest,
  HttpResponse,
  StreamChunk,
  HttpRequestStart,
  FetchHttpResponse,
  CacheGet,
  CacheGetReady,
  CacheSet,
  CacheSetReady,
  CryptoDigest,
  CryptoDigestReady,
  CryptoRandomValues,
  CryptoRandomValuesReady,
  SourceMap,
  SourceMapReady,
  DataPut,
  DataGet,
  DataGetReady,
  DataDel,
  DataDropCollection,
  DnsQuery,
  DnsRequest,
  DnsResponse,
}

enum ErrorKind: byte {
  NoError = 0,
  String,
  // io errors

  NotFound,
  PermissionDenied,
  ConnectionRefused,
  ConnectionReset,
  ConnectionAborted,
  NotConnected,
  AddrInUse,
  AddrNotAvailable,
  BrokenPipe,
  AlreadyExists,
  WouldBlock,
  InvalidInput,
  InvalidData,
  TimedOut,
  Interrupted,
  WriteZero,
  Other,
  UnexpectedEof,

  // url errors

  EmptyHost,
  IdnaError,
  InvalidPort,
  InvalidIpv4Address,
  InvalidIpv6Address,
  InvalidDomainCharacter,
  RelativeUrlWithoutBase,
  RelativeUrlWithCannotBeABaseBase,
  SetHostOnCannotBeABaseUrl,
  Overflow,

  // hyper errors

  HttpUser,
  HttpClosed,
  HttpCanceled,
  HttpParse,
  HttpOther
}

table Base {
  cmd_id: uint32;
  sync: bool = false;
  error_kind: ErrorKind = NoError;
  error: string;
  msg: Any;
}

table TimerStart {
  id: uint;
  delay: uint;
}

table TimerReady {
  id: uint;
  canceled: bool;
}

table TimerClear {
  id: uint;
}

enum HttpMethod: byte {
  Get = 0,
  Head,
  Post,
  Put,
  Patch,
  Delete,
  Connect,
  Options,
  Trace,
}

table HttpHeader {
  key: string;
  value: string;
}

table StreamChunk {
  id: uint;
  done: bool = false;
}

table HttpRequest {
  id: uint;
  method: HttpMethod;
  url: string;
  headers: [HttpHeader];
  body: bool;
}

table HttpResponse {
  id: uint;
  headers: [HttpHeader];
  status: ushort;
  body: bool;
}

table HttpRequestStart {
  id: uint;
}

table FetchHttpResponse {
  id: uint;
  headers: [HttpHeader];
  status: ushort;
  body: bool;
}

table CacheGet {
  key: string;
}

table CacheGetReady {
  id: uint;
  stream: bool;
}

table CacheSet {
  key: string;
}

table CacheSetReady {
  id: uint;
}

table CryptoDigest {
  algo: string;
}

table CryptoDigestReady {
  buffer: [ubyte];
}

table CryptoRandomValues {
  len: uint;
}

table CryptoRandomValuesReady {
  buffer: [ubyte];
}

table Frame {
  line: uint;
  col: uint;
  filename: string;
  name: string;
}

table SourceMap {
  frames: [Frame];
}

table SourceMapReady {
  frames: [Frame];
}

table DataPut {
  collection: string;
  key: string;
  json: string;
}
table DataGet {
  collection: string;
  key: string;
}
table DataGetReady {
  json: string;
}
table DataDel {
  collection: string;
  key: string;
}
table DataDropCollection {
  collection: string;
}

enum DnsRecordType: byte {
  A = 0,
  AAAA,
  ANY,
  AXFR,
  CAA,
  CNAME,
  IXFR,
  MX,
  NS,
  NULL,
  OPT,
  PTR,
  SOA,
  SRV,
  TLSA,
  TXT,
}

enum DnsResponseCode: byte {
  NoError = 0,
  FormErr,
  ServFail,
  NXDomain,
  NotImp,
  Refused,
  YXDomain,
  YXRRSet,
  NXRRSet,
  NotAuth,
  NotZone,
  BADVERS,
  BADSIG,
  BADKEY,
  BADTIME,
  BADMODE,
  BADNAME,
  BADALG,
  BADTRUNC,
  BADCOOKIE,
}

enum DnsOpCode: byte {
  Query = 0,
  Status,
  Notify,
  Update,
}

enum DnsMessageType: byte {
  Query = 0,
  Response,
}

enum DnsClass: byte {
  IN = 0,
  CH,
  HS,
  NONE,
  ANY,
  // OPT(u16) ?
}

union DnsRecordData {
  DnsA,
  DnsAAAA,
  // DnsCAA,
  DnsCNAME,
  DnsMX,
  // DnsNULL,
  DnsNS,
  // DnsOPT,
  DnsPTR,
  DnsSOA,
  DnsSRV,
  // DnsTLSA,
  DnsTXT,
  // TODO: more.
}

table DnsA {
  ip: string;
}
table DnsAAAA {
  ip: string;
}

table DnsCNAME {
  name: string;
}
table DnsMX {
  preference: ushort;
  exchange: string;
}
table DnsNS {
  name: string;
}
table DnsPTR {
  name: string;
}
table DnsSOA {
  mname: string;
  rname: string;
  serial: uint;
  refresh: int;
  retry: int;
  expire: int;
  minimum: uint;
}
table DnsSRV {
  priority: ushort;
  weight: ushort;
  port: ushort;
  target: string;
}

table DnsTXTData {
  data: [ubyte];
}

table DnsTXT {
  data: [DnsTXTData];
}

table DnsRequest {
  id: uint;
  type: DnsMessageType;
  queries: [DnsQuery];
}

table DnsQuery {
  name: string;
  type: DnsRecordType;
  dns_class: DnsClass;
}

table DnsRecord {
  name: string;
  type: DnsRecordType;
  rdata: DnsRecordData;
  dns_class: DnsClass;
  ttl: uint;
}

table DnsResponse {
  id: uint;
  op_code: DnsOpCode;
  type: DnsMessageType;
  authoritative: bool;
  truncated: bool;
  response_code: DnsResponseCode;
  answers: [DnsRecord];
  queries: [DnsQuery];
}

root_type Base;