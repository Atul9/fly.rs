// automatically generated by the FlatBuffers compiler, do not modify


#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Any {
  NONE = 0,
  TimerStart = 1,
  TimerReady = 2,
  TimerClear = 3
}

const ENUM_MIN_ANY: u8 = 0;
const ENUM_MAX_ANY: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for Any {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Any {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Any;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Any;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Any {
    type Output = Any;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Any>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_ANY:[Any; 4] = [
  Any::NONE,
  Any::TimerStart,
  Any::TimerReady,
  Any::TimerClear
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_ANY:[&'static str; 4] = [
    "NONE",
    "TimerStart",
    "TimerReady",
    "TimerClear"
];

pub fn enum_name_any(e: Any) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_ANY[index]
}

pub struct AnyUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum ErrorKind {
  NoError = 0
}

const ENUM_MIN_ERROR_KIND: i8 = 0;
const ENUM_MAX_ERROR_KIND: i8 = 0;

impl<'a> flatbuffers::Follow<'a> for ErrorKind {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for ErrorKind {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const ErrorKind;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const ErrorKind;
    unsafe { *p }
  }
}

impl flatbuffers::Push for ErrorKind {
    type Output = ErrorKind;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<ErrorKind>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_ERROR_KIND:[ErrorKind; 1] = [
  ErrorKind::NoError
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_ERROR_KIND:[&'static str; 1] = [
    "NoError"
];

pub fn enum_name_error_kind(e: ErrorKind) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_ERROR_KIND[index]
}

pub enum BaseOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Base<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Base<'a> {
    type Inner = Base<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Base<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Base {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BaseArgs<'args>) -> flatbuffers::WIPOffset<Base<'bldr>> {
      let mut builder = BaseBuilder::new(_fbb);
      if let Some(x) = args.msg { builder.add_msg(x); }
      if let Some(x) = args.error { builder.add_error(x); }
      builder.add_cmd_id(args.cmd_id);
      builder.add_msg_type(args.msg_type);
      builder.add_error_kind(args.error_kind);
      builder.add_sync(args.sync);
      builder.finish()
    }

    pub const VT_CMD_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SYNC: flatbuffers::VOffsetT = 6;
    pub const VT_ERROR_KIND: flatbuffers::VOffsetT = 8;
    pub const VT_ERROR: flatbuffers::VOffsetT = 10;
    pub const VT_MSG_TYPE: flatbuffers::VOffsetT = 12;
    pub const VT_MSG: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn cmd_id(&'a self) -> u32 {
    self._tab.get::<u32>(Base::VT_CMD_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn sync(&'a self) -> bool {
    self._tab.get::<bool>(Base::VT_SYNC, Some(true)).unwrap()
  }
  #[inline]
  pub fn error_kind(&'a self) -> ErrorKind {
    self._tab.get::<ErrorKind>(Base::VT_ERROR_KIND, Some(ErrorKind::NoError)).unwrap()
  }
  #[inline]
  pub fn error(&'a self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Base::VT_ERROR, None)
  }
  #[inline]
  pub fn msg_type(&'a self) -> Any {
    self._tab.get::<Any>(Base::VT_MSG_TYPE, Some(Any::NONE)).unwrap()
  }
  #[inline]
  pub fn msg(&'a self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Base::VT_MSG, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_timer_start(&'a self) -> Option<TimerStart> {
    if self.msg_type() == Any::TimerStart {
      self.msg().map(|u| TimerStart::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_timer_ready(&'a self) -> Option<TimerReady> {
    if self.msg_type() == Any::TimerReady {
      self.msg().map(|u| TimerReady::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_timer_clear(&'a self) -> Option<TimerClear> {
    if self.msg_type() == Any::TimerClear {
      self.msg().map(|u| TimerClear::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct BaseArgs<'a> {
    pub cmd_id: u32,
    pub sync: bool,
    pub error_kind: ErrorKind,
    pub error: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub msg_type: Any,
    pub msg: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for BaseArgs<'a> {
    #[inline]
    fn default() -> Self {
        BaseArgs {
            cmd_id: 0,
            sync: true,
            error_kind: ErrorKind::NoError,
            error: None,
            msg_type: Any::NONE,
            msg: None,
        }
    }
}
pub struct BaseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BaseBuilder<'a, 'b> {
  #[inline]
  pub fn add_cmd_id(&mut self, cmd_id: u32) {
    self.fbb_.push_slot::<u32>(Base::VT_CMD_ID, cmd_id, 0);
  }
  #[inline]
  pub fn add_sync(&mut self, sync: bool) {
    self.fbb_.push_slot::<bool>(Base::VT_SYNC, sync, true);
  }
  #[inline]
  pub fn add_error_kind(&mut self, error_kind: ErrorKind) {
    self.fbb_.push_slot::<ErrorKind>(Base::VT_ERROR_KIND, error_kind, ErrorKind::NoError);
  }
  #[inline]
  pub fn add_error(&mut self, error: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Base::VT_ERROR, error);
  }
  #[inline]
  pub fn add_msg_type(&mut self, msg_type: Any) {
    self.fbb_.push_slot::<Any>(Base::VT_MSG_TYPE, msg_type, Any::NONE);
  }
  #[inline]
  pub fn add_msg(&mut self, msg: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Base::VT_MSG, msg);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BaseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BaseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Base<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TimerStartOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct TimerStart<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TimerStart<'a> {
    type Inner = TimerStart<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TimerStart<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TimerStart {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TimerStartArgs) -> flatbuffers::WIPOffset<TimerStart<'bldr>> {
      let mut builder = TimerStartBuilder::new(_fbb);
      builder.add_delay(args.delay);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DELAY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn id(&'a self) -> u32 {
    self._tab.get::<u32>(TimerStart::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn delay(&'a self) -> u32 {
    self._tab.get::<u32>(TimerStart::VT_DELAY, Some(0)).unwrap()
  }
}

pub struct TimerStartArgs {
    pub id: u32,
    pub delay: u32,
}
impl<'a> Default for TimerStartArgs {
    #[inline]
    fn default() -> Self {
        TimerStartArgs {
            id: 0,
            delay: 0,
        }
    }
}
pub struct TimerStartBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TimerStartBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(TimerStart::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_delay(&mut self, delay: u32) {
    self.fbb_.push_slot::<u32>(TimerStart::VT_DELAY, delay, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TimerStartBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TimerStartBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TimerStart<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TimerReadyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct TimerReady<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TimerReady<'a> {
    type Inner = TimerReady<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TimerReady<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TimerReady {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TimerReadyArgs) -> flatbuffers::WIPOffset<TimerReady<'bldr>> {
      let mut builder = TimerReadyBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.add_canceled(args.canceled);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_CANCELED: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn id(&'a self) -> u32 {
    self._tab.get::<u32>(TimerReady::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn canceled(&'a self) -> bool {
    self._tab.get::<bool>(TimerReady::VT_CANCELED, Some(false)).unwrap()
  }
}

pub struct TimerReadyArgs {
    pub id: u32,
    pub canceled: bool,
}
impl<'a> Default for TimerReadyArgs {
    #[inline]
    fn default() -> Self {
        TimerReadyArgs {
            id: 0,
            canceled: false,
        }
    }
}
pub struct TimerReadyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TimerReadyBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(TimerReady::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_canceled(&mut self, canceled: bool) {
    self.fbb_.push_slot::<bool>(TimerReady::VT_CANCELED, canceled, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TimerReadyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TimerReadyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TimerReady<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TimerClearOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct TimerClear<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TimerClear<'a> {
    type Inner = TimerClear<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TimerClear<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TimerClear {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TimerClearArgs) -> flatbuffers::WIPOffset<TimerClear<'bldr>> {
      let mut builder = TimerClearBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&'a self) -> u32 {
    self._tab.get::<u32>(TimerClear::VT_ID, Some(0)).unwrap()
  }
}

pub struct TimerClearArgs {
    pub id: u32,
}
impl<'a> Default for TimerClearArgs {
    #[inline]
    fn default() -> Self {
        TimerClearArgs {
            id: 0,
        }
    }
}
pub struct TimerClearBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TimerClearBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(TimerClear::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TimerClearBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TimerClearBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TimerClear<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

